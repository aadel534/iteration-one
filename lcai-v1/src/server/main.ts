import express from "express";
// import ViteExpress from "vite-express";
// import { fileURLToPath } from "url";
import cors from "cors";
import mongoose from "mongoose";
import UserModel from "./models/mongodb.js";
import bcrypt from "bcrypt";
import { createServer } from "http";
import { Server } from "socket.io";
const app = express();
app.use(cors());
app.use(express.json());
import path from 'path';
import { fileURLToPath } from "url";

import {PORT, URI} from "../config/index.js";
// Dynamically generate paths

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
app.use(express.static(path.join(__dirname, '/../../dist')));



const httpServer = createServer(app);
const io = new Server(httpServer,
  {
    cors: {
      origin: "http:localhost:3000",
      methods: ["GET", "POST"],
    },

  }
);


io.on("connection", (socket) => {
  console.log("User connected");
  socket.on("disconnect", () => {
    console.log("User disconnected");
  })
})





mongoose.connect(URI)
  .then(() => {
    console.log("mongodb connected");
  })
  .catch(() => {
    console.log("failed to connect");
  });

// Single page application with single entry point (routes handled by client-side), redirects to home page
// when user makes a get request to '/register' for example 
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '..', '..', 'dist', 'index.html'));


});
// Email Regex generated by ChatGPT
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;
  if (!emailRegex.test(email)) {
    return res.status(400).json({ message: "That is not a valid email address." });
  }
  if (!email || !password) {
    return res.status(400).json({ message: "Please fill all of the fields!" });
  }
  if (password.length < 8) {
    return res.status(400).json({ message: "Passwords must have a length of 8 or greater." });
  }
  const userExists = await UserModel.findOne({ email });
  if (!userExists)
    {
      return res.status(404).json({ message: "There is no user registered with this account." });

    }
  else{
    const userDetailsCorrect = await bcrypt.compare(password, userExists.password);
    if (userDetailsCorrect)
      {
        return res.status(200).json({message: "Logging in..."});
        // Generating tokens for login/logout
        // https://dev.to/m_josh/build-a-jwt-login-and-logout-system-using-expressjs-nodejs-hd2

      }
      else
      {
        return res.status(401).json({ message: "Incorrect password." });
      }
  }

});

app.post("/api/register", async (req, res) => {
  const { forename, surname, email, password, passwordConfirmation } = req.body;
  // Secure password storage https://www.freecodecamp.org/news/how-to-hash-passwords-with-bcrypt-in-nodejs/
  if (!forename || !surname || !email || !password || !passwordConfirmation) {
    return res.status(400).json({ message: "Please fill all of the fields!" });
  }

  if (!emailRegex.test(email)) {
    return res.status(400).json({ message: "That is not a valid email address." });
  }

  if (password.length < 8) {
    return res.status(400).json({ message: "Passwords must have a length of 8 or greater." });
  }

  if (password !== passwordConfirmation) {
    return res.status(400).json({ message: "Passwords do not match!" });
  }

  // Check if user already exists
  const userExists = await UserModel.findOne({ email });
  if (userExists) {
    return res.status(400).json({ message: "An account already exists with this email!" });
  } else {
    if (password == passwordConfirmation) {
      const saltRounds = 12;
      const passwordHash = await bcrypt.hash(password, saltRounds);
      const newUser = new UserModel({
        firstName: forename,
        lastName: surname,
        email: email,
        password: passwordHash
      });
      await newUser.save();

    }
    else {
      return res.status(400).json({ message: "Passwords do not match!" });

    }

  };
});


httpServer.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});